<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stay Hungry, Stay Foolish.</title>
    <description>Just writing</description>
    <link>http://liuwei.co/</link>
    <atom:link href="http://liuwei.co/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 05 Feb 2017 23:18:42 +0800</pubDate>
    <lastBuildDate>Sun, 05 Feb 2017 23:18:42 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>PHP 命名空间说明</title>
        <description>&lt;p&gt;在PHP5.3版本中新添加了一个命名空间特性,许多现代流行的语言拥有这个特性已经有一段时间了，但是PHP这一特性有一点点姗姗来迟，当然了，每个新的特性都有它存在的意义，让我们看看为什么PHP的&lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt;有利于我们的应用程序。&lt;/p&gt;

&lt;p&gt;在PHP中，你不能同时定义一个相同名字的类，类名必须唯一。那么问题来了，如果你使用了一个第三方的库，这个库中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;类，那么你在创建你自己的类时就不能命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;了。这就尴尬了，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;这个名字太普遍了，对吧？&lt;/p&gt;

&lt;p&gt;PHP命名空间帮我们解决了这个问题，实际上我们想创建多少个&lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;类就可以创建多少个，不仅仅如此，我们也可以使用命名空间是我们的代码分门别类，或者显示组织结构。&lt;/p&gt;

&lt;p&gt;让我们看一眼一个正经的类(类的确是类，正不正经我不知道)，嗯，我知道你曾经这么使用过，相信我这一次吧。（仿佛看见了作者神秘的微笑…）&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;全局命名空间&lt;/h3&gt;

&lt;p&gt;这是一个极其简单的类.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// app/models/Eddard.php

class Eddard
{

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;没有什么特别的，如果我们要使用上面这个类，我们可以这样做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// app/routes.php

$eddard = new Eddard();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;黛尔, 我感觉我的智商受到了极大的侮辱…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好吧，开玩笑啦，言归正传，我们可以想象这个类是在一个全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;命名空间中。我不清楚这样说是否正确，但是对我而言貌似还是比较合适的，它本质是说，那个类没有命名空间。它只是一个标准的类而已。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简单的命名空间&lt;/h3&gt;

&lt;p&gt;让我们在之前的那个’全局的Eddard’类旁边创建另一个类:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Stark;

// app/models/another.php

class Eddard
{

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我们创建了另一个Eddard类，仅仅做了一个小小的修改。添加了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt;指令，在&lt;code class=&quot;highlighter-rouge&quot;&gt;namespace Stark&lt;/code&gt;这一行。&lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt;指令告诉PHP我们所有写的代码都是相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stark&lt;/code&gt;命名空间下的。它也表示所有在这个文件中创建的类将被包含在’Stark’命名空间里。&lt;/p&gt;

&lt;p&gt;现在，我们再次使用’Stark’类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// app/routes.php

$eddard = new Eddard();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再一次，我们获取到了上个章节创建的类的实例，不是在’Stark’命名空间下的那个实例。下面让我们创建一个’Stark’命名空间下的’Eddard’实例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// app/routes.php

$eddard = new Stark\Eddard();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以采用在命名空间名称中加前缀的方式实例化某个命名空间下的类，在’Stark’和’Eddard’之间用一个反斜杠(\)来分隔，现在我们有了一个’Stark’命名空间下的’Eddard’实例，腻害了，我的哥！&lt;/p&gt;

&lt;p&gt;你需要注意的是，命名空间可以有无限个层级，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This\Namespace\And\Class\Combination\Is\Silly\But\Works
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;相对论&lt;/h3&gt;

&lt;p&gt;还记得我曾经告诉过你的，PHP总是运行与当前命名空间相关的文件，好的，下面让我们看看这个特性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Stark;

// app/routes.php

$eddard = new Eddard();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;像上面这个实例化的例子，我们添加了命名空间指令，我们将PHP脚本移到了’Stark’命名空间下，现在由于我们在同一个命名空间下，这次我们获取的是’Stark’命名空间下的’Eddard’实例。不用我说了吧，你懂的。&lt;/p&gt;

&lt;p&gt;现在我们改变了命名空间，那么，问题来了，你知道是什么问题吗？那就是我们怎么实例化最初的那个’Eddard’类呢，就是那个没有命名空间的，我称它为’全局命名空间’的那个’Eddard’类。&lt;/p&gt;

&lt;p&gt;幸运的是，PHP有一个引用全局命名空间下的类的方式，我们只需要简单的加上反斜杠(\)前缀即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// app/routes.php

$eddard = new \Eddard();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有了这个主反斜杠(\),PHP知道引用的是全局命名空间下的’Eddard’类，所以PHP会实例化这个类。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文中 “Use your imagine a little, like how Barney showed you. “这句话我不知道怎么翻译，我Google了一下，Barney应该是美国比较流行的一个电视剧里面的紫色小恐龙。作者应该是想说再多想一点，正如Barney教会你的。当然这是我瞎猜的，如果猜错了，来咬我啊～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20161228/Barney&amp;amp;Friends.jpeg&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;咳，咳，当然这并不影响我继续翻译，试想一下，如果我们有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Edmure&lt;/code&gt;类在&lt;code class=&quot;highlighter-rouge&quot;&gt;Tully&lt;/code&gt;命名空间中，我们想在’Stark’命名空间中如何调用？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Stark;

// app/routes.php

$edmure = new \Tully\Edmure();

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再一次用到了斜杠前缀(\)，我们需要使用斜杠(\)前缀，让程序会到全局命名空间中，然后再从’Tully’命名空间实例化该类。&lt;/p&gt;

&lt;p&gt;每一次使用完整的层级路径来引用相关的类未免有点折腾人了，幸运的是，有一个不错的快捷方式，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;语句，让我们看看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Stark;

use Tully\Edmure;

// app/routes.php

$edmure = new Edmure();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;语句，我们把一个类引入到当前的命名空间，这样我们在实例化类的时候只需要提供名字就可以了。现在，不要问我为什么它不需要使用反斜杠做前缀，因为我也不知道。这是我所知道的唯一例外，我很抱歉！如果你愿意你可以加上前缀，不过你不需要这么做。&lt;/p&gt;

&lt;p&gt;为了弥补这个讨厌的不一致，让我展示给你另外一个巧妙的方式，我们可以给我们导入的类起一个别名。正如我们在PHP playground做的一样，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Stark;

use Tully\Brynden as Blackfish;

// app/routes.php

$brynden = new Blackfish();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;采用&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;关键字，我们给了’Tully/Brynden’类一个叫做’Blackfish’的别名，巧妙的方式，对吧！而且，如果你需要在同一个命名空间下使用两个相同类名的类，这也很有帮助。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Targaryen;

use Dothraki\Daenerys as Khaleesi;

// app/routes.php

class Daenerys
{

}

// Targaryen\Daenerys
$daenerys = new Daenerys();

// Dothraki\Daenerys
$khaleesi = new Khaleesi();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过给’Dothraki’命名空间下的’Daenerys’类一个别名’Khaleesi’,我们可以仅仅使用名称就可以调用两个’Daenerys’类了，而不需要加上冗长的命名空间层级。很方便使用，不是吗？这就是为了避免冲突，分门别类的目的。&lt;/p&gt;

&lt;p&gt;你想要&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;多少个类，就可以&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;多少个类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Targaryen;

use Dothraki\Daenerys;
use Stark\Eddard;
use Lannister\Tyrion;
use Snow\Jon as Bastard;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;结构&lt;/h3&gt;

&lt;p&gt;命名空间不仅仅只是关于避免冲突，我们可以用它来组织代码结构和所有者，让我用另一个栗子来解释一下。&lt;/p&gt;

&lt;p&gt;假如我们想创建一个开源库，我喜欢别人使用我的代码，那感觉超屌！问题是，我不想给使用我的库的兄弟们增添有关类名冲突的麻烦，那将是不好使用体验。为了让开源代码友好，易于嵌入，更独立，下面是我如何避免解决这个问题的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dayle\Blog\Content\Post
Dayle\Blog\Content\Page
Dayle\Blog\Tag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我用了我的名字作为命名空间来存放源代码，对于使用我的库的人来说也是这么分割我的代码的，在基命名空间&lt;code class=&quot;highlighter-rouge&quot;&gt;Dayle&lt;/code&gt;下，我创建了一些子命名空间来组织我程序的内部结构。&lt;/p&gt;

&lt;p&gt;在composer章节，你将学习到如何使用命名空间来简化你所定义的类，我墙裂推荐你看看这个有用的机制。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;限制&lt;/h3&gt;

&lt;p&gt;实际上，起’限制’这个子标题，我感觉有些不妥，我所说的’限制’并不是一个真正的bug。&lt;/p&gt;

&lt;p&gt;你知道，在其他语言中，命名空间有相似的实现方式，当不同命名空间之间相互调用的时候，他们提供一个额外的特性来简化操作。&lt;/p&gt;

&lt;p&gt;拿Java来举栗吧，你可以使用通配符导入某个命名空间下的所有类，在Java中，&lt;code class=&quot;highlighter-rouge&quot;&gt;import&lt;/code&gt;关键字相当于这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;,并且它使用点(.)来分割嵌套的命名空间（Java中叫包），下面是个栗子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import dayle.blog.*;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这会导入’dayle.blog’包下的所有类。&lt;/p&gt;

&lt;p&gt;而在PHP中你做不到，你需要分别导入每一个类。抱歉，实际上，为什么我要说抱歉呢？去向PHP的内部组抱怨啊，不，你需要冷静点，他们已经给了我们许多很酷很有用的东西啦。&lt;/p&gt;

&lt;p&gt;然而这里有一个巧妙的技巧，想象我们有这个命名空间和类结构，正如之前的栗子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dayle\Blog\Content\Post
Dayle\Blog\Content\Page
Dayle\Blog\Tag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以给子命名空间起一个别名来使用它下面的类，下面是一个栗子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

namespace Baratheon;

use Dayle\Blog as Cms;

// app/routes.php

$post = new Cms\Content\Post;
$page = new Cms\Content\Page;
$tag  = new Cms\Tag;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这对使用同一个命名空间下的许多类很有效，希望你喜欢！&lt;/p&gt;

&lt;p&gt;原文链接: &lt;a href=&quot;https://daylerees.com/php-namespaces-explained/&quot;&gt;https://daylerees.com/php-namespaces-explained/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/php/namespaces/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/2016/12/28/php-namespaces-explained.html</link>
        <guid isPermaLink="true">http://liuwei.co/php/namespaces/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/2016/12/28/php-namespaces-explained.html</guid>
        
        
        <category>PHP</category>
        
        <category>namespaces</category>
        
        <category>命名空间</category>
        
      </item>
    
      <item>
        <title>iOS10请求隐私权限的设置 - Info.plist</title>
        <description>&lt;p&gt;在访问用户手机通讯录,相册,地址,日历等隐私数据前需要向用户请求使用权限，在iOS10中，苹果公司加强了对隐私控制的审查，你必须在&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.plist&lt;/code&gt;文件中对所有需要访问的隐私数据作出声明。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20161224/ios10.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;frameworkinfoplistprivacy-key&quot;&gt;哪些&lt;code class=&quot;highlighter-rouge&quot;&gt;framework&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.plist&lt;/code&gt;中有&lt;code class=&quot;highlighter-rouge&quot;&gt;privacy key&lt;/code&gt;：&lt;/h5&gt;

&lt;p&gt;Calendar , Contact , Reminder , Photo , Bluetooth Sharing , Microphone , Camera , Location , Heath , HomeKit , Media Library , Motion , CallKit , Speech Recognition , SiriKit , TV Provider.&lt;/p&gt;

&lt;h5 id=&quot;privacy-key&quot;&gt;如果不提供&lt;code class=&quot;highlighter-rouge&quot;&gt;privacy key&lt;/code&gt;会报什么错误：&lt;/h5&gt;

&lt;p&gt;如果你不在&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.plist&lt;/code&gt;中提供指定的&lt;code class=&quot;highlighter-rouge&quot;&gt;privacy key&lt;/code&gt;，你的应用程序会没有任何商量余地的直接崩溃！以下是崩溃日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The app has crashed because it attempted to access privacy-sensitive data without a usage description. The app&#39;s Info.plist must contain an NSCalendarsUsageDescription key with a string value explaining to the user how the app user how the app uses this data.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section&quot;&gt;如何解决这个错误呢:&lt;/h5&gt;

&lt;p&gt;当然是根据你相应的请求在Info.pist中给出相应的privacy key啦。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20161224/privacykeys.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Calendar :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Calendars Usage Description    &lt;br /&gt;
Value  :  $(PRODUCT_NAME) calendar events&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Reminder :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :   Privacy - Reminders Usage Description    &lt;br /&gt;
Value  :   $(PRODUCT_NAME) reminder use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Contact :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key       :   Privacy - Contacts Usage Description     &lt;br /&gt;
Value    :  $(PRODUCT_NAME) contact use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key       :  Privacy - Photo Library Usage Description    &lt;br /&gt;
Value   :  $(PRODUCT_NAME) photo use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bluetooth Sharing :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key       :  Privacy - Bluetooth Peripheral Usage Description     &lt;br /&gt;
Value   :  $(PRODUCT_NAME) Bluetooth Peripheral use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Microphone :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key        :  Privacy - Microphone Usage Description    &lt;br /&gt;
Value    :  $(PRODUCT_NAME) microphone use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key       :  Privacy - Camera Usage Description   &lt;br /&gt;
Value   :  $(PRODUCT_NAME) camera use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Location :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Location Always Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) location use&lt;/p&gt;

&lt;p&gt;Key       :  Privacy - Location When In Use Usage Description   &lt;br /&gt;
Value   :  $(PRODUCT_NAME) location use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Heath :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Health Share Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) heath share use&lt;/p&gt;

&lt;p&gt;Key      :  Privacy - Health Update Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) heath update use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HomeKit :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - HomeKit Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) home kit use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Media Library :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Media Library Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) media library use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Motion :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Motion Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) motion use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Speech Recognition :&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Speech Recognition Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) speech use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SiriKit  : &lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - Siri Usage Description  &lt;br /&gt;
Value  :  $(PRODUCT_NAME) siri use&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TV Provider : &lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
Key      :  Privacy - TV Provider Usage Description   &lt;br /&gt;
Value  :  $(PRODUCT_NAME) tvProvider use&lt;/p&gt;

&lt;p&gt;谢谢阅读&lt;/p&gt;

&lt;p&gt;原文链接: &lt;a href=&quot;https://iosdevcenters.blogspot.com/2016/09/infoplist-privacy-settings-in-ios-10.html&quot;&gt;https://iosdevcenters.blogspot.com/2016/09/infoplist-privacy-settings-in-ios-10.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/error/info.plist/ios/ios%2010/privacy%20settings/swift%202.3/swift%203.0/xcode%208.0/2016/12/24/infoplist-privacy-settings-in-ios-10.html</link>
        <guid isPermaLink="true">http://liuwei.co/error/info.plist/ios/ios%2010/privacy%20settings/swift%202.3/swift%203.0/xcode%208.0/2016/12/24/infoplist-privacy-settings-in-ios-10.html</guid>
        
        
        <category>Error</category>
        
        <category>Info.plist</category>
        
        <category>iOS</category>
        
        <category>iOS 10</category>
        
        <category>Privacy Settings</category>
        
        <category>Swift 2.3</category>
        
        <category>Swift 3.0</category>
        
        <category>Xcode 8.0</category>
        
      </item>
    
      <item>
        <title>常用的一些xcode插件</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/supermarin/Alcatraz&quot;&gt;Alcatraz&lt;/a&gt;：管理xcode插件的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/XVimProject/XVim&quot;&gt;XVim&lt;/a&gt;：模拟vim编辑模式的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/MakeZL/ZLGotoSandboxPlugin&quot;&gt;ZLGotoSandboxPlugin&lt;/a&gt;：快速进入模拟器路径的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot;&gt;VVDocumenter-Xcode&lt;/a&gt;：帮助快速注释的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/acoomans/ACCodeSnippetRepositoryPlugin&quot;&gt;ACCodeSnippetRepositoryPlugin&lt;/a&gt;：使用git仓库同步常用代码片段的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/zats/AdjustFontSize-Xcode-Plugin&quot;&gt;AdjustFontSize-Xcode-Plugin&lt;/a&gt;：调整字体大小的插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/DeepIT/XcodeColors&quot;&gt;XcodeColors&lt;/a&gt;：把控制台输出的log加上不同的颜色&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/qfish/XAlign&quot;&gt;XAlign&lt;/a&gt;：格式化代码&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/ios/xcode/2015/10/07/xcode-plugin.html</link>
        <guid isPermaLink="true">http://liuwei.co/ios/xcode/2015/10/07/xcode-plugin.html</guid>
        
        
        <category>iOS</category>
        
        <category>Xcode</category>
        
      </item>
    
      <item>
        <title>一个有意思的终端录制&amp;分享工具</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://asciinema.org/&quot;&gt;asciinema&lt;/a&gt;：终端录制与屏幕分享工具&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/tool/%E5%B7%A5%E5%85%B7/2015/10/05/asciinema.html</link>
        <guid isPermaLink="true">http://liuwei.co/tool/%E5%B7%A5%E5%85%B7/2015/10/05/asciinema.html</guid>
        
        
        <category>Tool</category>
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>CoreText的内存管理</title>
        <description>&lt;h3 id=&quot;coretext&quot;&gt;CoreText的内存管理&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先我要说明的是,我并没有在官方文档中查到有明确指出ARC情况下使用CoreText需要手动管理内存，如果有人查到具体文档，请告知我。但是基于以下几点，我仍然坚信，我们是需要手动释放的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;一，引起关注的原因：&lt;/h4&gt;

&lt;p&gt;之前看到一段代码，隐隐感觉CTFontRef并没有释放。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        for (int i=0; i &amp;lt; array.count; i++) {
            IFAAttributeModel* model = [array objectAtIndex:i];
            if ([model isKindOfClass:[IFAAttributeModel class]]) {
                if (model.string == nil) {
                    continue;
                }
                NSInteger currentLength = [model.string length];
                CTFontRef font = CTFontCreateWithName(CFSTR(&quot;Helvetica&quot;), model.fontSize, NULL);
                [totalAttr addAttribute:(id)kCTFontAttributeName value:(__bridge id)font range:NSMakeRange(lastIndex, currentLength)];
                [totalAttr addAttribute:(NSString*)NSForegroundColorAttributeName value:model.color range:NSMakeRange(lastIndex, currentLength)];
                lastIndex = lastIndex + currentLength;
            }
        }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二，验证自己的想法&lt;/h4&gt;

&lt;p&gt;1,根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Core_Text&quot;&gt;维基百科&lt;/a&gt;上的解释，Core Text是Core Foundation风格的API，而Core Foundation是不受ARC管理的，因此我们需要手动管理内存。并且在它下面的Example中，是对CTFontRef进行CFRelease的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Prepare font
CTFontRef font = CTFontCreateWithName(CFSTR(&quot;Times&quot;), 48, NULL);

// Create an attributed string
CFStringRef keys[] = { kCTFontAttributeName };
CFTypeRef values[] = { font };
CFDictionaryRef attr = CFDictionaryCreate(NULL, (const void **)&amp;amp;keys, (const void **)&amp;amp;values,
					  sizeof(keys) / sizeof(keys[0]), &amp;amp;kCFTypeDictionaryKeyCallBacks, &amp;amp;kCFTypeDictionaryValueCallBacks);
CFAttributedStringRef attrString = CFAttributedStringCreate(NULL, CFSTR(&quot;Hello, World!&quot;), attr);
CFRelease(attr);

// Draw the string
CTLineRef line = CTLineCreateWithAttributedString(attrString);
CGContextSetTextMatrix(context, CGAffineTransformIdentity);  //Use this one when using standard view coordinates
//CGContextSetTextMatrix(context, CGAffineTransformMakeScale(1.0, -1.0)); //Use this one if the view&#39;s coordinates are flipped

CGContextSetTextPosition(context, 10, 20);
CTLineDraw(line, context);

// Clean up
CFRelease(line);
CFRelease(attrString);
CFRelease(font);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2, 对于Core Foundation的内存管理，苹果有&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-CJBEJBHH&quot;&gt;明确的规则&lt;/a&gt;，对于方法名有着约定俗成的规则，如下：&lt;/p&gt;

&lt;p&gt;There are many ways in which you can get a reference to an object using Core Foundation. In line with the Core Foundation ownership policy, you need to know whether or not you own an object returned by a function so that you know what action to take with respect to memory management. Core Foundation has established a naming convention for its functions that allows you to determine whether or not you own an object returned by a function. In brief, if a function name contains the word “Create” or “Copy”, you own the object. If a function name contains the word “Get”, you do not own the object. These rules are explained in greater detail in The Create Rule and The Get Rule.&lt;/p&gt;

&lt;p&gt;3, 查看Apple的&lt;a href=&quot;https://developer.apple.com/library/prerelease/mac/samplecode/CoreTextRTF/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007772-Intro-DontLinkElementID_2&quot;&gt;Sample Code&lt;/a&gt;的代码，也是对CTFontRef进行了释放。&lt;/p&gt;

&lt;p&gt;4, 最后我们做一个demo来验证&lt;/p&gt;

&lt;p&gt;新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Single View Application&lt;/code&gt;的xcode项目，在ViewController.m文件中模拟之前的代码编写一个如下的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)test
{
    NSMutableAttributedString* totalAttr = [[NSMutableAttributedString alloc]initWithString:@&quot;1234567890&quot;];
    
    CTFontRef font = CTFontCreateWithName(CFSTR(&quot;Helvetica&quot;), 24, NULL);
    
    NSLog(@&quot;%li&quot;,CFGetRetainCount(font));
    
    id oFont = (__bridge id)font;
    
    NSLog(@&quot;%li&quot;,CFGetRetainCount(font));
    
    [totalAttr addAttribute:(id)kCTFontAttributeName value:oFont range:NSMakeRange(0, 2)];
    
    NSLog(@&quot;%li&quot;,CFGetRetainCount(font));

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;方法中添加如下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (YES) {
            [self test];
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;按快捷键command＋r运行项目。在Debug Navigator中可以看到Memory一直在持续的上涨。&lt;/p&gt;

&lt;p&gt;现在我们在test方法最下面添加释放代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CFRelease(font);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再次command+r运行，可以看到此时Memory并没有持续上涨。&lt;/p&gt;

&lt;p&gt;综上所述，我们需要对CTFontCreateWithName创建的CTFontRef进行CFRelease释放操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实解决这个问题还有一种方式，将是将&lt;code class=&quot;highlighter-rouge&quot;&gt;__bridge&lt;/code&gt;换成&lt;code class=&quot;highlighter-rouge&quot;&gt;__bridge_transfer&lt;/code&gt;,这样就不需要手动&lt;code class=&quot;highlighter-rouge&quot;&gt;CFRelease&lt;/code&gt;了，代码如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; -(void)test
{
    NSMutableAttributedString* totalAttr = [[NSMutableAttributedString alloc]initWithString:@&quot;1234567890&quot;];
    
    CTFontRef font = CTFontCreateWithName(CFSTR(&quot;Helvetica&quot;), 24, NULL);
    
    NSLog(@&quot;%li&quot;,CFGetRetainCount(font));
    
    id oFont = (__bridge_transfer id)font;
    
    NSLog(@&quot;%li&quot;,CFGetRetainCount(font));
    
    [totalAttr addAttribute:(id)kCTFontAttributeName value:oFont range:NSMakeRange(0, 2)];
    
    NSLog(@&quot;%li&quot;,CFGetRetainCount(font));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;编译运行，内存也没有持续上涨，这主要得益于&lt;code class=&quot;highlighter-rouge&quot;&gt;__bridge_transfer&lt;/code&gt;将Core Foundation的对象转换为Objective-C对象的同时将对象的内存管理权交给了ARC，ARC帮我们release了。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/library/prerelease/mac/samplecode/CoreTextRTF/Introduction/Intro.html&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/legacy/library/samplecode/CoreTextTest/Listings/main_c.html#//apple_ref/doc/uid/DTS10004140-main_c-DontLinkElementID_4&lt;/p&gt;

&lt;p&gt;https://en.wikipedia.org/wiki/Core_Text&lt;/p&gt;

&lt;p&gt;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#bridged-casts&lt;/p&gt;

&lt;p&gt;http://www.yifeiyang.net/development-of-the-iphone-simply-6/&lt;/p&gt;

&lt;p&gt;http://blog.sina.com.cn/s/blog_6dce99b10101kux4.html&lt;/p&gt;

</description>
        <pubDate>Sun, 04 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/ios/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2015/10/04/coreText-memory-manage-in-ios.html</link>
        <guid isPermaLink="true">http://liuwei.co/ios/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2015/10/04/coreText-memory-manage-in-ios.html</guid>
        
        
        <category>iOS</category>
        
        <category>内存管理</category>
        
      </item>
    
      <item>
        <title>如何优雅的解决消息转发问题</title>
        <description>&lt;h4 id=&quot;objectivec&quot;&gt;ObjectiveC如何优雅的解决消息转发问题&lt;/h4&gt;

&lt;p&gt;很多时候我们需要实现这样一种场景，我们需要继承系统的View，比如UITextField，然后在我们的自定义TextField中拦截UITextFieldDelegate的某些方法，在拦截代码中实现一些自定义逻辑。&lt;/p&gt;

&lt;p&gt;如果给我写，我可能会在我们自定义的TextField中再定义一个delegate2,这是一种非常傻瓜的方式，并且需要实现原先系统的UITextFieldDelegate中的所有方法，最近看到我们组里大神写的代码，才知道我真的是图样图森破了。&lt;/p&gt;

&lt;p&gt;主要是用到&lt;code class=&quot;highlighter-rouge&quot;&gt;forwardingTargetForSelector&lt;/code&gt;来做消息转发。这是Objective C运行时（runtime）技术，很强大，我自己测试的示例代码已经放到&lt;a href=&quot;https://github.com/liuweicode/MessageInterceptorDemo&quot;&gt;github&lt;/a&gt;上了，有了这个，以后就可以做很多工作了，后面还需要深入研究。&lt;/p&gt;

&lt;p&gt;最后再说一下里面用到的一段代码，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOL selector_belongsToProtocol(SEL selector, Protocol * protocol)
{
    for (int optionbits = 0; optionbits &amp;lt; (1 &amp;lt;&amp;lt; 2); optionbits++) {
        BOOL required = optionbits &amp;amp; 1;
        BOOL instance = !(optionbits &amp;amp; (1 &amp;lt;&amp;lt; 1));
        
        struct objc_method_description hasMethod = protocol_getMethodDescription(protocol, selector, required, instance);
        if (hasMethod.name || hasMethod.types) {
            return YES;
        }
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;刚开始看到这个方法整个人有点懵，为什么这么写就能判断出某个Selector是不是某个协议里的方法，后来突然开窍，原来是&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol_getMethodDescription&lt;/code&gt;方法的后两个参数，是否必须（required），是否是实例方法（instance），两个Bool，总共4种可能，只要其中有一个得到了方法名（hasMethod.name）并且得到了方法类型（hasMethod.types），那么这个方法一定属于这个协议了。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;http://stackoverflow.com/questions/3498158/intercept-objective-c-delegate-messages-within-a-subclass&lt;/p&gt;

&lt;h4 id=&quot;todo&quot;&gt;TODO&lt;/h4&gt;

&lt;p&gt;深入了解&lt;code class=&quot;highlighter-rouge&quot;&gt;forwardingTargetForSelector&lt;/code&gt;的消息转发机制。&lt;/p&gt;
</description>
        <pubDate>Sat, 03 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/ios/2015/10/03/message-forward.html</link>
        <guid isPermaLink="true">http://liuwei.co/ios/2015/10/03/message-forward.html</guid>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>UIScrollView 教程（swift）</title>
        <description>&lt;p&gt;UIScrollView 在ios开发中是非常有用的控件之一。它是UITableView的基础，并且是展示内容大于屏幕的一种非常好的方式。在这篇UIScrollView教程中，你将学到这个控件的如下使用方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何使用一个UIScrollView展示一张大图。&lt;/li&gt;
  &lt;li&gt;当缩放UIScrollView的时候，如何保持UIScrollView的content居中。&lt;/li&gt;
  &lt;li&gt;如何嵌入复杂的视图到UIScrollView。&lt;/li&gt;
  &lt;li&gt;如何使用UIScrollView的可翻页特性，如何配合UIPageControl，进行滚动翻页显示。&lt;/li&gt;
  &lt;li&gt;如何显示当前页的时候能够看到上一页/下一页的内容。&lt;/li&gt;
  &lt;li&gt;还有更多！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这篇教程假定你熟悉swift和ios编程。如果你是一个新手，也许你希望从本网站了解一些&lt;a href=&quot;http://www.raywenderlich.com/?page_id=2519&quot;&gt;其他教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同样，这篇教程也假定你知道怎么使用Interface Builder来添加新控件到一个View上，并在你的代码和Storybard之间进行连接。在继续之前你需要熟悉Storyboards，所以如果你对Storyboards或者Interface Builder不熟悉，你需要在本站看看这些&lt;a href=&quot;http://www.raywenderlich.com/?p=5138&quot;&gt;Storyboards教程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;开始&lt;/h2&gt;

&lt;p&gt;打开Xcode创建一个新的项目，选择&lt;code class=&quot;highlighter-rouge&quot;&gt;File\New\Project…&lt;/code&gt;,然后选择&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS\Application\Single View Application&lt;/code&gt;模板，在product name输入&lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollViews&lt;/code&gt;，在language一栏选择Swift，然后在devices上选择&lt;code class=&quot;highlighter-rouge&quot;&gt;iPhone&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/Create_Project-700x413.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Next&lt;/code&gt;,然后选择一个目录存放你的项目。&lt;/p&gt;

&lt;p&gt;然后，为这个项目&lt;a href=&quot;http://cdn1.raywenderlich.com/downloads/ScrollViewsResources.zip&quot;&gt;下载资源&lt;/a&gt;，然后拖动解压后的文件到项目根目录，确保&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;Copy items if needed&quot;&lt;/code&gt;复选框是选中状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/Copy_Resources-700x412.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于这篇教程打算阐明scroll view的四个用法，这个项目将用一个四个选项的tableview菜单，每一个选项将打开一个新的view controller来显示scroll view的某一用法。&lt;/p&gt;

&lt;p&gt;当你完成后，应该类似下面的样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/Storyboard_Overall-655x500.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;构建tableview菜单，需要以下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打开Main.storyboard，删除已经存在的view controller&lt;/li&gt;
  &lt;li&gt;这篇教程关闭了Auto Layout。从Utilities面板，选择File Inspector，然后取消Use Auto Layout复选框，在弹出框上，确保“Keep size class data for:”是选择了iPhone，然后选择Disable Size Classes按钮。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/Disable_Size_Classes.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下一步，在storyboard上添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Table View Controller&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;现在，选中你添加的table，然后选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor\Embed In\Navigation Controller&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;选中新的Navigation Controller，然后在Attributes inspector上选中&lt;code class=&quot;highlighter-rouge&quot;&gt;Is Initial View Controller&lt;/code&gt;复选框。&lt;/li&gt;
  &lt;li&gt;在table view controller上选择table view，然后在attributes inspector设置content type为静态单元格&lt;code class=&quot;highlighter-rouge&quot;&gt;Static Cells&lt;/code&gt;（如下图所示）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/Static_Cells.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在storyboard层级上，在文档大纲上点击Table View左边的箭头，然后选中&lt;code class=&quot;highlighter-rouge&quot;&gt;Table View Section&lt;/code&gt;。在inspector，设置行的数量为4.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/UIScrollView-table-view-section.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;table view的每一行，设置style为&lt;code class=&quot;highlighter-rouge&quot;&gt;Basic&lt;/code&gt;,然后编辑labels内容如下：
    &lt;ul&gt;
      &lt;li&gt;Image Scroll&lt;/li&gt;
      &lt;li&gt;Custom View Scroll&lt;/li&gt;
      &lt;li&gt;Paged&lt;/li&gt;
      &lt;li&gt;Paged with Peeking&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;

  &lt;p&gt;备注：当你设置每个table row的style为“Basic”，table row将得到一个额外的子控件 － label，你需要再次展开它来编辑他们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;保存storyboard，然后编译运行。你会看到你的table view，类似下面的图片，遗憾的事，此时此刻tableview还没有任何东西，但是你可以修复它！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150818/Scroll_View_Run_11-281x500.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;滚动和缩放一张大图&lt;/h2&gt;

&lt;p&gt;你需要学习的第一件事是如何设置一个scroll view，允许用户缩放和平移。&lt;/p&gt;

&lt;p&gt;首先，你需要一个建立一个view controller。打开&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewController.swift&lt;/code&gt;， 然后在顶部定义类的地方，让他实现&lt;code class=&quot;highlighter-rouge&quot;&gt;UIScrollViewDelegate&lt;/code&gt;协议。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewController: UIViewController, UIScrollViewDelegate {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在类定义的内部，添加下面的outlet属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@IBOutlet var scrollView: UIScrollView!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下一步你需要连接这个属性到真实的scroll view。&lt;/p&gt;

&lt;p&gt;打开storyboard，并且从对象库中拖动一个&lt;code class=&quot;highlighter-rouge&quot;&gt;View Controller&lt;/code&gt;到画布，选中这个新的view controller，并且在Identity Inspector上设置class为&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/View_controller_class-_type.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个view controller将显示一个图片事例。从table view的&lt;code class=&quot;highlighter-rouge&quot;&gt;Image Scroll&lt;/code&gt;行上按住control键单击，然后拖动到新的view controller。在弹出的菜单上,选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Selection Segue&lt;/code&gt;下的&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;选项。这样，当用户选择第一行，view controller被推到了navigation的栈上。&lt;/p&gt;

&lt;p&gt;从对象库里拖动一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Scroll View&lt;/code&gt;填充到view controller上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Add_Scroll_View-293x500.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把scroll view连接到view controller，并且把scroll view的代理（delegate）设置为view controller。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Scroll_View_Outlets.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，你需要坐下来并且编写你的代码，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewController.swift&lt;/code&gt;,并且添加一个新的属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var imageView: UIImageView!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这将在用户四处滚动的时候持有image view。&lt;/p&gt;

&lt;p&gt;现在，是时候设置scroll view最有趣的部分了。用以下代码替换&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override func viewDidLoad() {
  super.viewDidLoad()
 
  // 1
  let image = UIImage(named: &quot;photo1.png&quot;)!
  imageView = UIImageView(image: image)
  imageView.frame = CGRect(origin: CGPoint(x: 0, y: 0), size:image.size)
  scrollView.addSubview(imageView)
 
  // 2
  scrollView.contentSize = image.size
 
  // 3
  var doubleTapRecognizer = UITapGestureRecognizer(target: self, action: &quot;scrollViewDoubleTapped:&quot;)
  doubleTapRecognizer.numberOfTapsRequired = 2
  doubleTapRecognizer.numberOfTouchesRequired = 1
  scrollView.addGestureRecognizer(doubleTapRecognizer)
 
  // 4
  let scrollViewFrame = scrollView.frame
  let scaleWidth = scrollViewFrame.size.width / scrollView.contentSize.width
  let scaleHeight = scrollViewFrame.size.height / scrollView.contentSize.height
  let minScale = min(scaleWidth, scaleHeight);
  scrollView.minimumZoomScale = minScale;
 
  // 5
  scrollView.maximumZoomScale = 1.0
  scrollView.zoomScale = minScale;
 
  // 6
  centerScrollViewContents()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这似乎看起来有些复杂，所以让我们一步一步分解它。你会觉得它并没有那么糟糕。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先，你需要用你之前添加到项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;photo1.png&lt;/code&gt;图片创建一个image view，这里强制解包表示如果它找不到photo1.png图片则会崩溃。这会早点提醒你不要忘记添加那个文件到项目中。下一步，你设置image view的frame（它的大小和位置），让他位于父视图的(0,0)坐标点和它的尺寸，最后，添加image view作为scroll view的子视图。&lt;/li&gt;
  &lt;li&gt;你需要告诉scroll view的contentsize，让它知道可以横向纵向可以滚动多远，在当前这个例子，它的contentsize是图片的size。&lt;/li&gt;
  &lt;li&gt;这里设置双击放大手势，你不需要&lt;code class=&quot;highlighter-rouge&quot;&gt;UIPinchGestureRecognizer&lt;/code&gt;来放大，因为UIScrollView已经内置有一个了！&lt;/li&gt;
  &lt;li&gt;下一步，你需要为scroll view计算出最小缩放，一个zoom scale表示content被正常显示的大小，小于1的zoom scale显示缩小内容，大于1的zoom scale显示放大的内容。获取最小的zoom scale，你基于它的宽度计算需要缩小多少让图片正好适配scroll view的边界。然后你需要针对图片的高度作出同样的计算，那两个最小的计算结果是scroll view的最小缩放。当完全缩小你可以看见全部的图片。&lt;/li&gt;
  &lt;li&gt;你设置最大缩放为1，因为放到比图片的分辨率还大会引起图片模糊，你设置初始缩放为最小，让图片已开始完全缩小。&lt;/li&gt;
  &lt;li&gt;调用一个帮助方法让图片在scroll view居中，帮助方法在哪里，下面就来讲。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;centerScrollViewContents&lt;/code&gt;的实现到类中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func centerScrollViewContents() {
  let boundsSize = scrollView.bounds.size
  var contentsFrame = imageView.frame
 
  if contentsFrame.size.width &amp;lt; boundsSize.width {
    contentsFrame.origin.x = (boundsSize.width - contentsFrame.size.width) / 2.0
  } else {
    contentsFrame.origin.x = 0.0
  }
 
  if contentsFrame.size.height &amp;lt; boundsSize.height {
    contentsFrame.origin.y = (boundsSize.height - contentsFrame.size.height) / 2.0
  } else {
    contentsFrame.origin.y = 0.0
  }
 
  imageView.frame = contentsFrame
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个方法的关键是解决一个小问题：如果scroll view的contentsize比它的边界小，然后它位于左上角，而不是在中心，如果你允许用户完全缩小，如果图片在视图中心将是极好的。这个方法实现了让图片始终在scroll view边界的中心。&lt;/p&gt;

&lt;p&gt;最后，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;scrollViewDoubleTapped&lt;/code&gt;的实现到类中，实现双击手势。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func scrollViewDoubleTapped(recognizer: UITapGestureRecognizer) {
  // 1        
  let pointInView = recognizer.locationInView(imageView)
 
  // 2
  var newZoomScale = scrollView.zoomScale * 1.5
  newZoomScale = min(newZoomScale, scrollView.maximumZoomScale)
 
  // 3
  let scrollViewSize = scrollView.bounds.size
  let w = scrollViewSize.width / newZoomScale
  let h = scrollViewSize.height / newZoomScale
  let x = pointInView.x - (w / 2.0)
  let y = pointInView.y - (h / 2.0)
 
  let rectToZoomTo = CGRectMake(x, y, w, h);
 
  // 4
  scrollView.zoomToRect(rectToZoomTo, animated: true)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当双击的时候这个方法被调用，下面一步一步指导发生了什么：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先，你需要知道在图片控件的哪里被点击了，你需要直接在那个点上放大，这或许是作为一个用户所期望的。&lt;/li&gt;
  &lt;li&gt;下一步，你计算一个zoom scale让它放大150%，但是超过了你在&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;里面定义的最大缩放。&lt;/li&gt;
  &lt;li&gt;然后使用第一步的位置来计算一个用来放大的&lt;code class=&quot;highlighter-rouge&quot;&gt;CGRect&lt;/code&gt;矩形。&lt;/li&gt;
  &lt;li&gt;最后，你需要告诉scroll view放大，并且这里你需要让他看起来有一个不错的动画。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于ios不同手势的更多信息，查看&lt;a href=&quot;http://www.raywenderlich.com/?p=76020&quot;&gt;UIGestureRecognizer tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在，还记住你是如何设置&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewController&lt;/code&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;UIScrollViewDelegate&lt;/code&gt;的吗？是的，现在你需要实现那个协议里面的一些方法。添加下面的方法到类中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func viewForZoomingInScrollView(scrollView: UIScrollView!) -&amp;gt; UIView! {
  return imageView
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是scroll view缩放机制的核心，它告诉scroll view当捏放的时候哪个视图需要变的更大或者更小。所以告诉它是&lt;code class=&quot;highlighter-rouge&quot;&gt;imageView&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;最后，添加下面的代理方法到类中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func scrollViewDidZoom(scrollView: UIScrollView!) {
  centerScrollViewContents()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当用户完成缩放scroll view将调用这个方法，这里，你需要view重新放到中心，scroll view不会自然的出现放大，取而代之的是，它会排在左上角。&lt;/p&gt;

&lt;p&gt;现在，深呼吸，给你自己拍拍后背，编译并且运行你的项目！如果一切顺利，在&lt;code class=&quot;highlighter-rouge&quot;&gt;scroll view&lt;/code&gt;上单击。你最终会有一个完美的可以缩放，移动和单击的图片，太棒了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Scroll_View_Run_2-281x500.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;滚动和缩放一个有层级的视图&lt;/h2&gt;

&lt;p&gt;如果你希望在你的scroll view里面放多个视图，而不仅仅是一张图片，如果你有一个复杂的层级视图需要可以被缩放和移动，当然，scroll view可以做到这些！更重要的是，它在你已经完成的基础上仅仅需要一小步。&lt;/p&gt;

&lt;p&gt;创建一个新文件，选择&lt;code class=&quot;highlighter-rouge&quot;&gt; iOS\Source\Cocoa Touch Class &lt;/code&gt;模板。设置class名为&lt;code class=&quot;highlighter-rouge&quot;&gt;CustomScrollViewController&lt;/code&gt;，然后设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的子类，确保“Also create XIB file” 复选框没有选中，设置语言为&lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt;.点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Next&lt;/code&gt;然后保存到项目里。&lt;/p&gt;

&lt;p&gt;打开&lt;code class=&quot;highlighter-rouge&quot;&gt;CustomScrollViewController.swift&lt;/code&gt;,然后用下面的内容替换：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit
 
class CustomScrollViewController: UIViewController, UIScrollViewDelegate {
  @IBOutlet var scrollView: UIScrollView!
 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下一步，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Main.storyboard&lt;/code&gt;,像刚刚一样添加&lt;code class=&quot;highlighter-rouge&quot;&gt;View Controller&lt;/code&gt;并从table view的第二行连线。设置view controller的class为你刚刚创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;CustomScrollViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Scroll View&lt;/code&gt;并且连接它到outlet，并且像刚刚一样设置view controller作为它的代理。&lt;/p&gt;

&lt;p&gt;然后，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;CustomScrollViewController.swift&lt;/code&gt;并且在scrollView outlet下面的添加属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var containerView: UIView!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与之前不同的是containerView替代了&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView&lt;/code&gt;,它是怎样工作的应该是一个小小的提示。&lt;/p&gt;

&lt;p&gt;现在，像这样实现&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override func viewDidLoad() {
  super.viewDidLoad()
 
  // Set up the container view to hold your custom view hierarchy
  let containerSize = CGSize(width: 640.0, height: 640.0)
  containerView = UIView(frame: CGRect(origin: CGPoint(x: 0, y: 0), size:containerSize))
  scrollView.addSubview(containerView)
 
  // Set up your custom view hierarchy
  let redView = UIView(frame: CGRect(x: 0, y: 0, width: 640, height: 80))
  redView.backgroundColor = UIColor.redColor();
  containerView.addSubview(redView)
 
  let blueView = UIView(frame: CGRect(x: 0, y: 560, width: 640, height: 80))
  blueView.backgroundColor = UIColor.blueColor();
  containerView.addSubview(blueView)
 
  let greenView = UIView(frame: CGRect(x: 160, y: 160, width: 320, height: 320))
  greenView.backgroundColor = UIColor.greenColor();
  containerView.addSubview(greenView)
 
  let imageView = UIImageView(image: UIImage(named: &quot;slow.png&quot;))
  imageView.center = CGPoint(x: 320, y: 320);
  containerView.addSubview(imageView)
 
  // Tell the scroll view the size of the contents
  scrollView.contentSize = containerSize;
 
  // Set up the minimum &amp;amp; maximum zoom scales
  let scrollViewFrame = scrollView.frame
  let scaleWidth = scrollViewFrame.size.width / scrollView.contentSize.width
  let scaleHeight = scrollViewFrame.size.height / scrollView.contentSize.height
  let minScale = min(scaleWidth, scaleHeight)
 
  scrollView.minimumZoomScale = minScale
  scrollView.maximumZoomScale = 1.0
  scrollView.zoomScale = 1.0
 
  centerScrollViewContents()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;设置一个视图作为视图层级的根视图。这就是之前设置的实力变量&lt;code class=&quot;highlighter-rouge&quot;&gt;containerView&lt;/code&gt;。然后添加这个根视图到scroll view。这是关键，如果你打算让view被放大，只能有一个view可以被添加到scroll view。因为正如你将回调的，你在代理的回调方法&lt;code class=&quot;highlighter-rouge&quot;&gt;viewForZoomingInScrollView&lt;/code&gt;只能返回一个视图。你设置&lt;code class=&quot;highlighter-rouge&quot;&gt;zoomScale&lt;/code&gt;为1代替&lt;code class=&quot;highlighter-rouge&quot;&gt;minScale&lt;/code&gt;,使contentview正常大小，代替屏幕大小。&lt;/p&gt;

&lt;p&gt;同样的，实现&lt;code class=&quot;highlighter-rouge&quot;&gt;centerScrollViewContents&lt;/code&gt;和两个&lt;code class=&quot;highlighter-rouge&quot;&gt;UIScrollViewDelegate&lt;/code&gt;的代理方法。对于原先的版本，用&lt;code class=&quot;highlighter-rouge&quot;&gt;containerView&lt;/code&gt;取代&lt;code class=&quot;highlighter-rouge&quot;&gt;imageView&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func centerScrollViewContents() {
  let boundsSize = scrollView.bounds.size
  var contentsFrame = containerView.frame
 
  if contentsFrame.size.width &amp;lt; boundsSize.width {
    contentsFrame.origin.x = (boundsSize.width - contentsFrame.size.width) / 2.0
  } else {
    contentsFrame.origin.x = 0.0
  }
 
  if contentsFrame.size.height &amp;lt; boundsSize.height {
    contentsFrame.origin.y = (boundsSize.height - contentsFrame.size.height) / 2.0
  } else {
    contentsFrame.origin.y = 0.0
  }
 
  containerView.frame = contentsFrame
}
 
func viewForZoomingInScrollView(scrollView: UIScrollView!) -&amp;gt; UIView! {
  return containerView
}
 
func scrollViewDidZoom(scrollView: UIScrollView!) {
  centerScrollViewContents()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;备注：你可能留意到了&lt;code class=&quot;highlighter-rouge&quot;&gt;UITapGestureRecognizer&lt;/code&gt;的不足。这是让这部分教程更简单。随意添加进去作为额外的练习。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在编译并且运行你的项目，这次，点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Custom View Scroll&lt;/code&gt;,然后平移和缩放，是不是很棒？&lt;/p&gt;

&lt;h2 id=&quot;uiscrollview&quot;&gt;可翻页的UIScrollView&lt;/h2&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://www.raywenderlich.com/76436/use-uiscrollview-scroll-zoom-content-swift&quot;&gt;UIScrollView Tutorial: Getting Started&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/tutorial/translation/uiscrollview/ios/2015/08/18/use-uiscrollview-scroll-zoom-content-swift.html</link>
        <guid isPermaLink="true">http://liuwei.co/tutorial/translation/uiscrollview/ios/2015/08/18/use-uiscrollview-scroll-zoom-content-swift.html</guid>
        
        
        <category>tutorial</category>
        
        <category>translation</category>
        
        <category>UIScrollView</category>
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>提高IOS开发效率的一些小技巧</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;一，快捷键&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.添加删除当前行快捷键&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;找到Deletion节点，添加以下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;key&amp;gt;Delete Current Line&amp;lt;/key&amp;gt; 
&amp;lt;string&amp;gt;deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;依次点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;xcode -&amp;gt; Preferences -&amp;gt; Key Bindings&lt;/code&gt; 在输入框中输入delete current line , 在右边的Key一栏中绑定快捷键，这里我喜欢Eclipse的风格&lt;code class=&quot;highlighter-rouge&quot;&gt;command + d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150817/xcode-command+d.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.修改默认快捷键&lt;/h3&gt;

&lt;p&gt;平时在开发过程中，我用到最多的快捷键是布局界面的切换和查找，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20150817/xcode-shortcut-key.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;code-snippets&quot;&gt;二，Code Snippets&lt;/h2&gt;

&lt;p&gt;把一些常用的代码块作为自定义code snippets，这个因人而异。我这里定义了一些常用的注释，GCD，ifelse，switch等。&lt;br /&gt;
这里推荐一个插件，&lt;a href=&quot;https://github.com/acoomans/ACCodeSnippetRepositoryPlugin&quot;&gt;ACCodeSnippetRepository&lt;/a&gt;   &lt;br /&gt;
这个是我的snippets repository：https://github.com/liuweicode/snippets&lt;/p&gt;

&lt;h2 id=&quot;xcode&quot;&gt;三，xcode插件&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/supermarin/Alcatraz&quot;&gt;Alcatraz&lt;/a&gt;：Package manager for Xcode&lt;/p&gt;

</description>
        <pubDate>Sun, 16 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/trick/skill/xcode/ios/2015/08/16/some-tricks-to-improve-efficiency-of-development.html</link>
        <guid isPermaLink="true">http://liuwei.co/trick/skill/xcode/ios/2015/08/16/some-tricks-to-improve-efficiency-of-development.html</guid>
        
        
        <category>trick</category>
        
        <category>skill</category>
        
        <category>xcode</category>
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>搭建个人知识管理平台</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;环境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ECS 1核/1G/CentOS6.5 x64&lt;/li&gt;
  &lt;li&gt;Nginx 1.0.15&lt;/li&gt;
  &lt;li&gt;Nodejs v0.12.7&lt;/li&gt;
  &lt;li&gt;Forever v0.15.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;前期服务器搭建，反向代理设置等已经做好，下面只记录一下Raneto的安装过程。主要是针对自己的喜好，做了一些修改。&lt;/p&gt;

&lt;h3 id=&quot;ranetohttpsgithubcomgilbitronranetoreleases&quot;&gt;1.下载 &lt;a href=&quot;https://github.com/gilbitron/Raneto/releases&quot;&gt;Raneto&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;目前最新版本v0.6.0，下载并解压到网站根目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/gilbitron/Raneto/archive/0.6.0.tar.gz
tar -zxvf 0.6.0.tar.gz -C /home/wwwroot/
cd /home/wwwroot/
mv Raneto-0.6.0 liuwei.co
chown www.www liuwei.co -R
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.修改首页列表宽度全屏&lt;/h3&gt;

&lt;p&gt;将首页列表宽度改成100%&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /home/wwwroot/liuwei.co
vim public/styles/raneto.css
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;将下面的代码添加到最后:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*将首页列表宽度改成100%*/
.col-sm-4 {
width: 100%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.添加中文搜索支持&lt;/h3&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://github.com/nandy007/lunr.js&quot;&gt;nandy007&lt;/a&gt;为lunr.js添加了中文搜索的支持，修改package.json：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;找到&lt;code class=&quot;highlighter-rouge&quot;&gt;dependencies&lt;/code&gt;节点下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;lunr&lt;/code&gt;模块，如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;dependencies&quot;: {
&quot;body-parser&quot;: &quot;~1.0.0&quot;,
&quot;cookie-parser&quot;: &quot;~1.0.1&quot;,
&quot;debug&quot;: &quot;~0.7.4&quot;,
&quot;express&quot;: &quot;~4.2.0&quot;,
&quot;extend&quot;: &quot;^1.2.1&quot;,
&quot;glob&quot;: &quot;^4.0.0&quot;,
&quot;hogan-express&quot;: &quot;^0.5.2&quot;,
&quot;lunr&quot;: &quot;^0.5.3&quot;,
&quot;marked&quot;: &quot;^0.3.2&quot;,
&quot;moment&quot;: &quot;^2.6.0&quot;,
&quot;morgan&quot;: &quot;~1.0.0&quot;,
&quot;raneto-core&quot;: &quot;0.x&quot;,
&quot;static-favicon&quot;: &quot;~1.0.0&quot;,
&quot;underscore&quot;: &quot;^1.6.0&quot;,
&quot;underscore.string&quot;: &quot;^2.3.3&quot;,
&quot;validator&quot;: &quot;^3.13.0&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;替换成下面的代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;dependencies&quot;: {
&quot;body-parser&quot;: &quot;~1.0.0&quot;,
&quot;cookie-parser&quot;: &quot;~1.0.1&quot;,
&quot;debug&quot;: &quot;~0.7.4&quot;,
&quot;express&quot;: &quot;~4.2.0&quot;,
&quot;extend&quot;: &quot;^1.2.1&quot;,
&quot;glob&quot;: &quot;^4.0.0&quot;,
&quot;hogan-express&quot;: &quot;^0.5.2&quot;,
&quot;lunr&quot;: &quot;https://github.com/liuweicode/lunr.js&quot;,
&quot;marked&quot;: &quot;^0.3.2&quot;,
&quot;moment&quot;: &quot;^2.6.0&quot;,
&quot;morgan&quot;: &quot;~1.0.0&quot;,
&quot;raneto-core&quot;: &quot;0.x&quot;,
&quot;static-favicon&quot;: &quot;~1.0.0&quot;,
&quot;underscore&quot;: &quot;^1.6.0&quot;,
&quot;underscore.string&quot;: &quot;^2.3.3&quot;,
&quot;validator&quot;: &quot;^3.13.0&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;forever&quot;&gt;4.安装依赖并forever启动&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
forever stop bin/www
forever start -e error.log bin/www  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5.打开浏览器访问&lt;/h3&gt;
&lt;p&gt;完毕&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;============2015年8月17日 修改================&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim views/home.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;找到&lt;code class=&quot;highlighter-rouge&quot;&gt;Main Articles&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;panel panel-default &quot;&amp;gt;
&amp;lt;!-- &amp;lt;h2 class=&quot;panel-heading&quot;&amp;gt;Main Articles&amp;lt;/h2&amp;gt; --&amp;gt;
&amp;lt;h2 class=&quot;panel-heading&quot;&amp;gt;To be a stronger and better version of myself!&amp;lt;/h2&amp;gt;
&amp;lt;ul class=&quot;list-group pages&quot;&amp;gt;

&amp;lt;li class=&quot;list-group-item page&quot;&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;

&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;首页添加日期显示&lt;/li&gt;
  &lt;li&gt;首页添加翻页功能&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 16 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/wiki/share/2015/08/16/create-a-personal-wiki-platform.html</link>
        <guid isPermaLink="true">http://liuwei.co/wiki/share/2015/08/16/create-a-personal-wiki-platform.html</guid>
        
        
        <category>Wiki</category>
        
        <category>Share</category>
        
      </item>
    
      <item>
        <title>一个不经意的内存泄露问题</title>
        <description>&lt;p&gt;最近在用Mediaplayer播放音乐的时候，Logcat总是打印如下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GC_CONCURRENT freed 118K, 42% free 3840K/6599K, external 2085K/2566K, paused 2ms+2ms
GC_CONCURRENT freed 224K, 38% free 4708K/7559K, external 2085K/2566K, paused 2ms+4ms
GC_CONCURRENT freed 283K, 34% free 5788K/8711K, external 2085K/2566K, paused 2ms+3ms
GC_CONCURRENT freed 361K, 30% free 7177K/10183K, external 2085K/2566K, paused 2ms+2ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不一会儿就内存溢出了.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I/dalvikvm-heap( 4883): Clamp target GC heap from 34.004MB to 32.000MB
D/dalvikvm( 4883): GC_FOR_MALLOC freed 0K, 9% free 28074K/30727K, external 2085K
/2566K, paused 178ms
I/dalvikvm-heap( 4883): Clamp target GC heap from 32.004MB to 32.000MB
I/dalvikvm-heap( 4883): Grow heap (frag case) to 32.000MB for 52-byte allocation

I/dalvikvm-heap( 4883): Clamp target GC heap from 34.004MB to 32.000MB
D/dalvikvm( 4883): GC_CONCURRENT freed &amp;lt;1K, 9% free 28074K/30727K, external 2085
K/2566K, paused 2ms+5ms
I/dalvikvm-heap( 4883): Clamp target GC heap from 34.004MB to 32.000MB
D/dalvikvm( 4883): GC_FOR_MALLOC freed 0K, 9% free 28074K/30727K, external 2085K
/2566K, paused 178ms
I/dalvikvm-heap( 4883): Clamp target GC heap from 32.004MB to 32.000MB
I/dalvikvm-heap( 4883): Grow heap (frag case) to 32.000MB for 24-byte allocation

I/dalvikvm-heap( 4883): Clamp target GC heap from 34.004MB to 32.000MB
D/dalvikvm( 4883): GC_FOR_MALLOC freed 0K, 9% free 28074K/30727K, external 2085K
/2566K, paused 177ms
I/dalvikvm-heap( 4883): Clamp target GC heap from 32.004MB to 32.000MB
I/dalvikvm-heap( 4883): Grow heap (frag case) to 32.000MB for 20-byte allocation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经过排查，不是Service跟Mediaplayer的原因，锁定了问题的原因是线程频繁更新剩余时间的TextView导致的。应该不会吧，我更新时间只有一个线程在跑，不可能线程数量过多导致内存溢出啊，于是我又换成broadcast，在Service中播放音乐的同时，sendbroadcast给Activity来更新Textview，问题依旧，我又换成Timer定时任务来做，依旧未能解决，我走在崩溃的边缘，连头发都凌乱了。不知何时，一位网友的话点醒了我，具体的网址记不清了，他说他以前遇到此问题是由于设置android:layout_weight属性导致控件频繁刷新，联想到我的剩余时间显示控件Textview的android:layout_width设置为wrap_content，由于播放过程中频繁刷新TextView导致内存溢出的，将该属性值改成120dip，问题解决！&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Mar 2013 00:00:00 +0800</pubDate>
        <link>http://liuwei.co/android/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2013/03/29/%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%BB%8F%E6%84%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">http://liuwei.co/android/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2013/03/29/%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%BB%8F%E6%84%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98.html</guid>
        
        
        <category>Android</category>
        
        <category>内存管理</category>
        
      </item>
    
  </channel>
</rss>
